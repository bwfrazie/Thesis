function [Ref,hFig,Handles] = plot_ref( ...
    arg1, gradMode, interpColor, lineColor, ref2rng, hAx )
%plot_ref - Plots contents of a TEMPER refractivity file (v3.0+).
%
%
% USE: [Ref,hFig] = plot_ref( Ref, gradMode, interpColor, lineColor, ref2rng, hAx )
%
%
% INPUTS: (all optional)
%
%    Ref - can be name of TEMPER input or refractivity file (string), a 
%       structure generated by read_ref.m, or empty ([]) to prompt for graphical 
%       file selection (the default).
%
%    gradMode - Integer flag that determines how gradients are plotted:
%        = 0 -> refractivity gradients not shown on plot
%        = 1 -> gradients shown as colorplot in background
%    (*) = 2 -> profile lines given gradient-dependent coloring
%       The default value is 1 (background colors), but when plotting a range-
%       dependent .ref file with no output arguments and the gradMode not
%       explicitely set, this function will prompt you to select gradMode.
%
%(*) interpColor - ColorSpec for "interpolation lines" (connections
%       between points in adjacent profiles; TEMPER will interpolate in
%       range along these lines).  Input can be a [1x3] RGB color, a
%       MATLAB-recognized string ('k', 'red', etc.), or empty.  Empty input
%       input (the default) prevents routine from plotting these lines.
%
%    lineColor - Color for lineplots of refractivity profiles.  Can be
%       RGB, colorspec or empty.  Default is 'k' (black).  Note that when
%       gradMode == 2, lineColor only affects the color of the M/N-units
%       scale bar; the refractivity lines will be colored by gradient.
%
%(*) ref2rng - Ratio of refractivity-units-to-range-units for line plots
%       of range-dependent profiles. Input empty [] to trigger default behavior,
%       which attempts to auto-scale the plots for multile-range profiles. You
%       can usually use the automatic setting, but if this is not working input
%       a value for ref2rng; larger values increase the overlap between adjacent
%       profiles. Something around 0.1 to 0.3 usually works well.
%
%    hAx - handle of an existing axis on which to plot; useful for putting
%       refractivity info in the background of an existing plot. Note that
%       behavior of the plotting is different depending on whether HOLD is ON or
%       OFF when you input an axes handle "hAx".
%
%   (*) These inputs do not affect plots of singe-range data.
%
% OUTPUT:
%
%    Ref  - structure used to generate the current plot.
%
%    hFig - handle of figure object used for plot.
%
%    Handles - optional 3rd output is a structure of graphics-object handles
%              within the plot.
%
%
% NOTES:
%
%   Function does not plot absorption data, even when data includes absorption
%   values.  Function has several customizable parameters hardcoded at the top
%   of the file.
%
%
% EXAMPLES:
%
%   % This example, range-dependent .ref file should be in same directory as
%   % plot_ref.m
%   Ref = read_ref('read_ref_test2.ref');
%
%   plot_ref( [], 0, 'm', 'b' ); % blue profiles, magenta interp lines
%
%   plot_ref( Ref, 0, 'm', 'b', 0.1 ); % same as above, narrower profile scaling
%
%   plot_ref( Ref, 0 ); % default-color profiles, no interp lines (default)
%
%   plot_ref( Ref, 1 ); % same as above, plus gradient colorplot background
%
%   plot_ref( Ref, 1, '', '' ); % no lines, same colorplot w/ brighter colors
%
%   plot_ref( Ref, 2 ); % no background, profile lines colored by gradient
%
%   % Here's an example of putting refractivity colors in the background of an
%   % existing plot. This particular example should work regardless of whether
%   % the .ref file is single-range or range-dependent.
%   figure; plot( [0,20], [0,500] );
%   hold on; plot_ref( Ref, 1, '', '', [], gca );
%
%
% USE: plot_ref -test
%
%   Triggers self-test mode. This is also a useful way to visualize all the
%   types of plots that may be created with various input settings; please run
%   test mode to see what you can get (and to make sure the function doesn't
%   break!).
%
%
% SEE ALSO: plot_ref_grads.m, reference_ref_grads.m, and >> mfilefind('ref')
%
%
% ©2003-2015, Johns Hopkins University / Applied Physics Lab
% Last update: 2015-12-12


% Update List: (all JZG)
% -----------
% 2003-03-18: Finished coding initial version.
% 2003-03-19: Fixed bug in filename title.  Improved comments.  Switched to
% zbuffer renderer.  Added internal "refScaleBarTextStandout" option.
% 2003-03-28: Added 'std' and 'duct' labels to colorbar.
% 2003-03-31: Modified colorbar to place std. atm. break in middle of center
% color (odd nCmapColors) w/ duct thresh 1.5 colors below (e.g on break)
% 2003-04-09: Added figure handle output, modified header comments.
% 2003-09-16: Added handling of transparent axes background in 
% "make_patch_under_text" subroutine.
% 2004-03-26: Adapted code to plot gradient colors for single-range profiles.
% Repeated top gradient to make plots include that layer in the color plot.
% 2004-05-07: Minor change to title string.
% 2004-08-17: Aethetic changes to look of single-profile plots.
% 2004-09-22: Increased nCmapColors from 15 to 18, and recoded so that std. atm
% is no longer in the middle.  More colors are now devoted to trapping
% (negative) gradients.  This mod also lifts the previous restriction that
% nCmapColors be odd - can now be any integer.
% 2005-11-04: Added WARNDLG to notify user of CHECK_REF() fails (previously
% returned w/out explanation or plot).  Removed 'NumberTitle','off' in call to
% figure.m.
% 2007-03-05: Changed to flat shading for all gradient colors; some modes had
% used interp shading and this yielded misleading plots for some cases.
% 2007-03-27: Still issues WARNDLG when CHECK_REF finds problems, but no longer
% refuses to attempt plotting of these .ref files; also, no longer print the
% auto "ref2rng" value to command window. Also changed defaults so that no lines
% are plotted when >= 100 profiles.
% 2007-12-12: Added .in-file capability via getset_temper_input().
% 2008-06-01: Removed ZOOM ON command
% 2008-06-12: Moved gradient-colormap code out into ref_grad_colormap.m; note
% that the "nCmapColors" parameter is now set in that external routine.
% 2009-11-05: Changed from refractivity min/max to [0, 1e6] for x-limits of
% gradient colors in single-profile mode. Plots may now be resized (axis)
% without having white space created at the left or right edges of the plot.
% 2013-08-20: Aesthetic changes to header comments + hAx input. Part of this
% change was addition of okToChangeAxes variable. A DISP() warning was inserted
% to not that the code has not been tested much yet when all the formatting that
% gets turned off by okToChangeAxes == false setting, which now happens when
% this function is called with a non-empty hAx *and* that axes has HOLD ON. Also
% added ui_grad_mode() and made some aesthetic changes to code (e.g., renamed
% structure from "S" to "Ref').
% 2013-12-16: Minor change to use unitflag2str.m instead of redundant code.
% Added double() casting due to glitches in bulitin Matlab 2011b functions. Also
% changed the check_ref warndlg to warning to make it less annoying.
% 2013-12-25: Realized that just a small change was needed to get code working
% on single-range waterfall (gradMode == 2) plots. Added a unit tester
% subroutine (it just makes plots). Also thickened up lines for both
% single-range (lineWidth of 3) and multi-range (new lineWidth of 1.5, vs. 0.5
% previously) plots. Also, Open GL is still generally problematic in Matlab.
% Added allowOpenGl flag + functionality and set it to FALSE to work around
% strange surface-object errors in Java / recent releases (R2011-R2013).
% 2014-01-03: Made 4/3-std line go lighter gray (almost white) when color
% background, and now outputting "Handles" struct to give external control over
% this (4/3-std line) and other objects that the user has no other way to
% control. Also swapped order of plotting so that std line goes underneath the
% interpolation lines which go underneath then refractivity line.
% 2015-01-25: Attempted to make ref_grad_colormap.m work with R2014b's new
% colorbar object, but had to resort to a band aide (see "fix" at bottom of main
% routine, as well as ref_grad_colormap.m code).
% 2015-02-03: Minor change, adapting to new "warning" mode for check_ref where a
% msg is generated but isOk still == true.
% 2015-02-05: Added R2014b work-around for shading flat glitch.
% 2015-02-22: More R2014b work-arounds (this function + in ref_grad_colormap.m).
% 2015-12-12: Patch to the 2015-02-22 mod, still no perfect solution to the
% R2014b issues.


    % For compatiblity w/ R13's logical 
    % type and pre-R13 versions...
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    true = (1==1);
    false = not(true);  
    
    % "Hardcoded" function parameters
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    fontSize = 12; % Determines font size for all text in figure. This setting 
        % is ignored if the optional hAx handle is provided.
    cmapFadeFactor = 2.0; % Must be >= one.  Higher numbers make colors
        % in gradient color-plot look more faded.
    maxFileChars = 40; % Limits length of filename shown in plot title.
        % When filenames are longer, the beginning of the filename is
        % clipped to meet this #-of-characters limit.
    defaultLineColor = 'k';
    refScaleBarNormHeight = 0.02; % Height of sides on refractivity units
        % scalebar (bar shown on range-dependent line plots to illustrate true
        % x-scale for refractivity).  This value is normalized to axes height.
        % Value does *not* control height or position of text that's included
        % with the scalebar.
    refScaleBarNormLLHC = [0.05,0.90]; % Sets lower-left-hand-corner of scale-
        % bar as [left,bottom], in units that are normalized to axes size.
        % Note that current settings do not cater to heights >= 1 (above plot).
    refScaleBarTextStandout = true; % If true, patchs are placed behind scale-
        % bar's text to make the characters stand out from any plot objects
        % underneath the text.  The patches are automatically given the same
        % color as the axes background (typically, white).
    useSameFigure = false; % If true, function plots to the same figure on
        % successive calls (Note: this is not the same as HOLD on; insatead,
        % this gives the figure a specific name and all successive calls to
        % plot_ref.m plot to this figure, regardless of GCF and HOLD ON/OFF).
        % This setting has no effect when the option "hAx" is input.
    showStdLine = true; % If true, plots include a dotted grey line that has
        % standard-atmosphere gradient, alligned with the start point of the
        % first profile.  Note that, even if this variable is true, gradient-
        % only colorplots will not include this standard-gradient line.
    allowOpenGl = false; % If false, code will force any plot that involves a 
        % surface object (gradModes 1 & 2) to use zbuffers for renderer, due to
        % both the general problems with OpenGL in Matlab throughout several
        % versions, as well as a specific issue (spanning at least R2011b to
        % R2013a) where surface plots can get completely hosed up when memory is
        % running low.    
        
        
    % Handle inputs
    %~~~~~~~~~~~~~~
    
    % Handle test-mode trigger first
    if ( nargin == 1 ) && ischar( arg1 ) && strcmpi( arg1, '-test' )
        run_test; return
    end

    % Set defaults for omitted arguments:
    if nargin < 1, arg1         = []; end % empty triggers graphical selection
    if nargin < 2, gradMode     = []; end
    if nargin < 3, interpColor  = ''; end
    if nargin < 4, lineColor    = defaultLineColor; end
    if nargin < 5, ref2rng      = []; end
    if nargin < 6, hAx          = []; end
    
    % Special handling for refractivity-data input:
    %   (empty) -> prompt for graphical selection
    %   (structure) -> check structure for errors
    %   (filename) -> use read_ref.m to get data
    % In all cases, the "Ref" variable will be set to a valid refractivity
    % structure after executing this if-block:
    if isempty(arg1)
        Ref = read_ref; % read_ref.m will prompt for graphical file selection
        if isempty(Ref), return; end
    elseif isstruct(arg1)
        [isOk,msg] = check_ref( arg1 );
        if not(isOk)
            warning(msg); % <- removed "return" 2007-03-27
        elseif ~isempty(msg)
            warning(msg);
        end 
        Ref = arg1;
    elseif ischar(arg1)
        if exist( arg1, 'file' )
            [junk,junk,extn] = fileparts(arg1);
            if strcmpi(extn,'.in')
                % New, 2007-12-12 -> handle .in file inputs
                inFile = arg1;
                arg1 = getset_temper_input(inFile,'get','refFile');
                if ~exist(arg1,'file')
                    error(['.ref file name/path in "',inFile,...
                           '" is no longer valid']);
                end
            end
            Ref = read_ref(arg1);
            if isempty(Ref), return; end
        else
            error(['Input file "',arg1,'" does not exist.']);
        end
    end

    % Special handling of defaults when .ref file has lots of profiles (added
    % 2007-03-27) -> only show colorplot of gradients, no lines:
    if ( nargin < 2 ) & ( Ref.n_profiles >= 100 )
        gradMode    = 1;
        interpColor = [];
        lineColor   = [];
    elseif isempty( gradMode )
        if ( Ref.n_profiles ) > 1 & ( nargout == 0 )
            gradMode = ui_grad_mode;
        else
            gradMode = 1;
        end
    end
    
    % Based on inputs, set flags that determine what gets plotted
    showGrad     = ( gradMode > 0 );
    useWaterfall = ( gradMode == 2 );
    showLines    = not( isempty( lineColor ) ) & not( useWaterfall );
    showInterp   = not( isempty( interpColor ) );
    
    % Convert TEMPER-style units flag (0/1) into units strings
    % for plotting labels and for input to "reference_ref_grads" function:
    [rngUnitStr,hgtUnitStr] = unitflag2str( Ref.units );
    
    % Added this 2013-12-16 in case user set single-precision values, to work
    % around builtin Matlab glitches (could have implemented this at the
    % check_ref level, but since plotting seems to be the only hang-up, at least
    % in R2011b, this allows users to have smaller-memory structures but still
    % generate proper plots using plot_ref.m):
    Ref.height       = double( Ref.height       );
    Ref.refractivity = double( Ref.refractivity );
    
    
    % Handle single-profile case by modifying
    % appropriate flags and constants.  If 
    % multiple profiles and no "ref2rng" input,
    % compute this factor automatically:
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if ( Ref.n_profiles == 1 )
        
        showInterp = false; % there aren't any interpolation lines for 1 profile
        
        ref2rng = 1; % scale factor for x-axis w.r.t. refractivity is 1.0 because
        % x-axis is refractivity in 1-profile case (vs. range x-axis when more
        % than 1 profile).
        
    elseif isempty( ref2rng )
        
        % Set "overlap factor", noting that 1 = no overlap & > 1 = overlapping
        overlapFactor = min( 5, Ref.n_profiles * 0.25 ); % <- new, 2015-12-29
        % (note that in line above, the factor of 0.25 is ad hoc, and can be
        % thought of as follows -> up to # of profiles = 5/0.25 = 20, code will
        % "squish" plots relative to its old behavior, but for # profiles >= 20
        % the behavior will be the same as old code -> %PRE: overlapFactor = 5; 
        %
        % TODO: make the "magic numbers" of 5 and 5/0.25 = 20 into constants,
        % defined at begining of the file, instead of hardcoded?
        
        perProfileWidth   = max(Ref.refractivity,[],1) - min(Ref.refractivity,[],1); % vector
        noOverlapWidthRef = max( perProfileWidth ); % scalar
        noOverlapWidthRng = Ref.range(end) / Ref.n_profiles; % assumes Ref.range(1) == 0.0
        ref2rngNoOverlap  = noOverlapWidthRng / noOverlapWidthRef;
        ref2rng = overlapFactor * ref2rngNoOverlap;
        
    end

    
    % Internal logical switches whose values
    % depend on input-controlled switches:
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    hasAnyLines = ( showLines | showInterp | useWaterfall );
    
    if not( hasAnyLines )
        showStdLine = false;
    end
        
    
    % Create array of x-axis data "xData",
    % used for line plots:
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    if ( hasAnyLines )

        xData = Ref.refractivity;

        % If only one profile, x-axis will be refractivity
        if ( Ref.n_profiles > 1 )
            % ... otherwise, need to adjust refractivity so that it
            % ... fits on a range scale:
            % Shift all profiles so that surface value is zero (array op)
            xData = xData - repmat( Ref.refractivity(1,:), size(xData,1), 1 );
            % Adjust values so that all profiles start at the correct
            % range, and are re-scaled such that one refractivity unit
            % is "ref2rng" range-units wide (array op):
            xData = repmat( Ref.range, size(xData,1), 1 ) + ref2rng.*xData;
        end

    end

    
    % Create figure & axes objects
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if isempty( hAx )
        
        figureName = 'Refractivity Data Plot';
        if ( useSameFigure )
            existingFigures = findobj('Name',figureName);
        else
            existingFigures = [];
        end

        if isempty( existingFigures )
            hFig = figure(...
                'Name',figureName,...
                'Renderer','zbuffer');
            % Note on renderer -> in auto mode, Matlab selects painters which
            % gets slow for more than 10-20 profiles, and OpenGL hasn't worked
            % right in PC MATLAB from R11 through R13. Just use zbuffer.
        else
            hFig = existingFigures(1); % (1) just in case there are multiple figures
            figure(hFig); % make current
            clf; % clears current figure of visible objects
        end

        hAx = axes(...
            'Parent',hFig,...
            'FontSize',fontSize); 
        
        okToChangeAxes = true;
        
    else
        
        try
            checkType = get( hAx, 'type' );
            if ~strcmpi( checkType, 'axes' )
                error('Input hAx is not a valid axes-object handle');
            end
        catch
            error( lasterr );
        end

        axes( hAx ); % <- make the input axes current
        hFig = gcf;
        okToChangeAxes = ~ishold;        
        
    end
    
    Handles.axes = hAx;
    
    if not( okToChangeAxes )
        %disp('Warning: this mode has not be thoroughly tested yet by JZG');
        % TODO: test more?
    end
    
    % Add lines & colorplots to figure
    % sequentially, using hold('on')
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    stdGrad = reference_ref_grads( Ref.ref_units, hgtUnitStr );

    if ( showStdLine )
        stdY = [ min(Ref.height(:)) , max(Ref.height(:)) ];
        stdX = xData(1,1) + (ref2rng*stdGrad).*( stdY );
        hasColorBackground = showGrad & not(useWaterfall);
        if ( hasColorBackground )
            stdColor  = [1,1,1];
            lineWidth = 2;
        else
            stdColor = [0.5,0.5,0.5];
            lineWidth = 1;
        end
        Handles.std_line = plot( stdX, stdY, 'LineStyle', '--', ...
            'Color', stdColor, 'LineWidth',lineWidth );
        hold('on'); % (in case there's more to plot)
    else
        Handles.std_line = [];
    end

    if ( showInterp )
        % Array op -> transpose so that connections between profiles
        % (rows) are plotted, instead of profiles (columns)
        Handles.interp_line = plot( xData.', Ref.height.', 'Color', interpColor );
        hold('on'); % (in case there's more to plot)
    else
        Handles.interp_line = [];
    end

    if ( showLines )
        % Array op -> plots all profiles (columns) at once
        Handles.ref_line = plot( xData, Ref.height, 'Color', lineColor );
        hold('on'); % (in case there's more to plot)
    else
        Handles.ref_line = [];
    end
    
    if ( showGrad )
        % NOTES:
        % -> SURF internally REPMAT's range vector into an array of the
        %   correct size
        % -> Plotting diff(2) at height(1) shows gradients in the correct
        %   position, given MATLAB's surface-plot conventions
        % -> Similarly, must repeat highest value in gradient array to make
        %   surface-plot include colors behind last two profile points.
        % -> "shading flat" produces the most accurate-looking plot
        % -> Plotting at a Z-location of -1.0 (arbitrary < 0.0) prevents
        %   surface from obscuring line plots at Z = 0.0 (this is also 
        %   the reason I'm using SURF instead of PCOLOR).
        % -> DIFF works down columns; refractivity & height arrays are
        %   arranges such that each column contains one profile
        gradientArray = diff(Ref.refractivity)./diff(Ref.height);
        % Need to repeat last Y,Z,C values for surf plot to look right
        gradientArray = gradientArray([1:end,end],:);
        surfZ = repmat( -1.0, size(gradientArray) );
        surfY = Ref.height;
        surfX = Ref.range;
        % Special handling for single-profile cases:
        if ( Ref.n_profiles == 1 )
            gradientArray = [ gradientArray , gradientArray ];
            surfZ = [ surfZ , surfZ ];
            surfY = [ surfY , surfY ];
            % make x coord wide enough to span any realistic range of M- or
            % N-units
            surfX = [0, 1e6]; %PRE: min(Ref.refractivity), max(Ref.refractivity) ];
            % If making a waterfall, need to double xData as well
            if ( useWaterfall )
                xData = [ xData , xData ];
            end
        end
        if ( useWaterfall )
            % Need to transpose arrays for waterfall plot to look right
            hSrf = waterfall(  xData.', ...
                        surfY.', ...
                        surfZ.', ...
                        gradientArray.' );
            if ( Ref.n_profiles == 1 )
                % To make it show up, need to thicken the surface object's
                % linewidth, which is not so easy to get to using (at least my)
                % typical formatting tools. 
                waterfallLineWidth = 3;
            else
                % Even multi-range waterfalls could use beefer lines:
                waterfallLineWidth = 1.5;
            end
            % Thicken the lines here:
            set( hSrf, 'LineWidth', waterfallLineWidth );
        else
            hSrf = surf(       surfX, ...
                        surfY, ...
                        surfZ, ...
                        gradientArray );
        end
        Handles.grad_surface = hSrf;
        % Moved custom colormap/colorbar-creating code into external function
        % 2008-06-12:
        if ( hasAnyLines & not(useWaterfall) )
            fadeFact = cmapFadeFactor;
        else
            fadeFact = 1;
        end
        Handles.colorbar = ref_grad_colormap( ...
            hFig, fadeFact, Ref.ref_units, hgtUnitStr, fontSize );        
        % NOTE: prior to 2007-03-05 when ~useWaterfall & ~( Ref.n_profiles == 1 )
        shading flat;
        if not( useWaterfall ) && has_r2014b_problems
            % Matlab R2014b does not seem to work for SHADING FLAT under some
            % circumstances, fix that here:
            set( hSrf, 'LineStyle', 'none' );
        end
        axes(hAx); % <- had to add this for R2014b for proper view (2015-02-22)
        view(2); % make SURF plot look like a PCOLOR plot
        hold('on'); % (in case there's more to plot)
        % New, 2013-12-25
        if not( allowOpenGl )
            if strcmpi( get(hFig,'renderer'), 'opengl' )
                warning('Changing figure renderer from OpenGL to Zbuffers');
                set(hFig,'renderer','zbuffer');
            end
        end        
    else
        Handles.grad_surface = [];
        Handles.colorbar     = [];
    end

    
    % Finished plotting  
    %~~~~~~~~~~~~~~~~~~~
    
    axes(hAx); % Make sure "ax" is current axes before calling high-level commands
    if ( okToChangeAxes )
        box('on');
        axis('tight');
    end
    
    if ( Ref.n_profiles == 1 )
        % Only one profile - put axis limits tight on the profile (not nec'ly
        % the standard atmosphere line!) and turn grid on.
        % kag 1/8/13
        % Add checks to make sure the min/max values are not the same.
        % the axis command throws an errror if they are the same.
        r1 = min(Ref.refractivity); 
        r2 = max(Ref.refractivity);
        if(r1==r2)
            r2 = r2+10^-12;
        end
        h1 = Ref.height(1);
        h2 = Ref.height(end);
        if(h2==h1)
            h2 = h2+10^-12;
        end
        axis([r1,r2,h1,h2]);
        if ( okToChangeAxes ), grid('on'); set(hAx,'layer','top'); end
    else
        % Multiple profiles - have Matlab's AXIS TIGHT command fit limits for
        % you, and turn grid off to prevent plot from looking too cluttered.
        if ( okToChangeAxes )
            axis('tight');
            grid('off');
        end
    end

    
    % Add plot title & labels
    %~~~~~~~~~~~~~~~~~~~~~~~~
    
    if ( okToChangeAxes )

        % Title:
        [junk,fileNameStr] = fileparts( Ref.file );
        [junk,subPathStr]  = fileparts( junk );
        titleFileStr = fullfile(subPathStr,fileNameStr);
        if length(titleFileStr) > maxFileChars
            titleFileStr = ['...',titleFileStr(end-maxFileChars+4:end)];
        end
        title( titleFileStr, 'FontSize',fontSize, 'interpreter','none' );

        % Y-axis label:
        ylabel(['Altitude [',hgtUnitStr,']'],'FontSize',fontSize)

        % X-axis label:
        if ( Ref.n_profiles == 1 )
            xLblStr = ['Refractivity [',Ref.ref_units,'-units]'];
        else
            xLblStr = ['Range [',rngUnitStr,']'];
        end
        if ( showGrad )
            xLblStr = [xLblStr, ' (color = gradient in ',Ref.ref_units,'/',hgtUnitStr,')'];
        end
        xlabel(xLblStr,'FontSize',fontSize);

    end
    
    % Create refractivity-units scale-
    % bar for multi-profile line plots:
    %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    if ( hasAnyLines & (Ref.n_profiles > 1) )

        % Need to position these text & line objects slightly higher than
        % the line objects at Z = 0.0 to ensure they're visible:
        scaleBarZpos = 1.0; % ( arbitrary - anything > 0.0 )
        
        % Need axes limits to compute actual scale-bar position
        % from normalized-position parameters:
        xLim = get(hAx,'XLim');  dx = diff(xLim);
        yLim = get(hAx,'YLim');  dy = diff(yLim);
        
        % Compute scale-bar refractivity limits as integer min/max
        % of input data.  Handle special case where min & max go
        % to the same integer by defaulting to a 1.0-unit-wide scale:
        minRefractivity = min( Ref.refractivity(:) );
        maxRefractivity = max( Ref.refractivity(:) );
        scaleBarLim = floor([minRefractivity,maxRefractivity]);
        scaleBarLim(2) = max( scaleBarLim(2), scaleBarLim(1) + 1.0 );

        % Width is set in axes units, not normalized
        refScaleBarWidth = ref2rng * diff(scaleBarLim);
        
        % Convert normalized width / LLHC to axes units
        % (normalized-position variables set in "hardcoded parameters"
        % section at top of file):
        refScaleBarHeight = dy * refScaleBarNormHeight;
        refScaleBarLLHC   = [xLim(1),yLim(1)] + [dx,dy].*refScaleBarNormLLHC;
        
        % Form Matlab position vector: [left,bottom,width,height]
        refScaleBarPos = [refScaleBarLLHC,refScaleBarWidth,refScaleBarHeight];
        
        % Make rectangle same color as line plots
        if isempty(lineColor),  scaleBarColor = defaultLineColor;
        else,                   scaleBarColor = lineColor;
        end
        
        % Make a line that follows the bottom and sides of the box
        % defined by "refScaleBarPos":
        Handles.ref2rng_line = line( ...
                'Parent', hAx,...
                'XData', refScaleBarPos(1) + [0,0,refScaleBarPos([3,3])],...
                'YData', refScaleBarPos(2) + [refScaleBarPos(4),0,0,refScaleBarPos(4)],...
                'ZData', scaleBarZpos([1,1,1,1]),...
                'Color', scaleBarColor,...
                'LineWidth', 2 );
        
        % Add text above left & right sides of box showing the
        % refractivity values they represent:
        for i = 1:2

            pos(1:2) = refScaleBarPos([1,2]) + [(i-1),1].*refScaleBarPos([3,4]);
            pos(3) = scaleBarZpos;

            hTxt = text(...
                'Parent', hAx, ...
                'Position', pos, ...
                'HorizontalAlignment', 'center', ...
                'VerticalAlignment', 'bottom', ...
                'FontWeight', 'bold', ...
                'FontSize', fontSize, ...
                'String', int2str(scaleBarLim(i)) );

            if ( refScaleBarTextStandout )
                hPatch = make_patch_under_text( hTxt );
            end
            
            Handles.ref2rng_patch(i) = hPatch;
            Handles.ref2rng_text(i)  = hTxt;

        end
        
        % Add text below box labeling refractivity units
        hTxt = text( ...
                'Parent', hAx, ...
                'Position', [refScaleBarPos(1)+refScaleBarPos(3)/2, ...
                             refScaleBarPos(2), ...
                             scaleBarZpos], ...
                'HorizontalAlignment', 'center', ...
                'VerticalAlignment', 'top', ...
                'FontWeight', 'bold', ...
                'FontSize', fontSize, ...
                'String', [Ref.ref_units,'-units'] );                

        if ( refScaleBarTextStandout )
            hPatch = make_patch_under_text( hTxt );
        end
            
        Handles.ref2rng_patch(end+1) = hPatch;
        Handles.ref2rng_text(end+1)  = hTxt;

    else
        
        Handles.ref2rng_line  = [];
        Handles.ref2rng_patch = [];
        Handles.ref2rng_text  = [];
        
    end      
    
    % Even with changes in ref_grad_colormap.m for R2014b, it still puts the
    % "ghost" axes behind the colorbar sometimes. Handle that problem here:
    if not( verLessThan( 'matlab', '8.4.0' ) ) & not( isempty( Handles.colorbar ) )
        axes( Handles.colorbar );
        %PRE: warning(['R2014b and later still have incompatible graphics objects',...
        %PRE:     ' w/ plot_ref colorbar labeling. Resizing this figure or setting',...
        %PRE:     ' the current axis will obscure or misalign the labels.']);
        % 2015-12-12 ad hoc adjustment
        set( Handles.colorbar, 'HandleVisibility','off',...
            'Xtick',[], 'Ytick',[] );
    end
    
return




function h = make_patch_under_text( textObj )
% Function creates a patch with same color as axes background just underneath
% the text in a text object.  The purpose is to mask that region of the plot so
% that the text is clearly visible.  Output is handle of the create patch
% object.

    textExtent = get( textObj, 'Extent' ); % [left,bottom,width,height]
    textXYZ = get( textObj, 'Position' );
    ax = get( textObj, 'Parent' );
    axColor = get( ax, 'Color' );
    isTransparent = 0;

    % Added 2003-09-16
    if any( isnan(axColor) )
        isTransparent = 1;
    elseif ischar( axColor )
        isTransparent = strcmpi( axColor, 'none' );
    elseif isempty( axColor )
        isTransparent = 1;
    end
    if (isTransparent)
        hFig = get( hAxes, 'Parent' );
        axColor = get( hFig, 'Color' );
    end

    h = patch( ...
        'Parent', ax,...
        'FaceColor', axColor, ...
        'LineStyle', 'none', ...
        'XData',textExtent([1 1 1 1]) + [0,0,textExtent([3 3])],...
        'YData',textExtent([2 2 2 2]) + [textExtent(4),0,0,textExtent(4)],...
        'ZData',textXYZ([3 3 3 3]) - eps );

return
            
           


function gradMode = ui_grad_mode

    opts = {'none','background colors','line colors'};
    question = 'How do you want to represent gradients on this range-dependent plot?';

    disp(sprintf('%s\n',...
        'NOTE:',...
        '  To avoid this dialog box,',...
       ['  ("',question,'")'],...
        '  either input a non-empty 2nd input argument (gradMode)',...
        '  or provide an explicit output argument (Ref = plot_ref ...).' ));
            
    response = questdlg( question, [mfilename,'.m wants to know...'], ...
                         opts{:}, opts{2} );
    
    if isempty( response )
        error('User hit CANCEL at gradMode prompt');
    end
    
    gradMode = strmatch( response, opts, 'exact' ) - 1;
    %        = 0 -> refractivity gradients not shown on plot
    %        = 1 -> (default) gradients shown as colorplot in background
    %    (*) = 2 -> profile lines given gradient-dependent coloring
    
return





%function run_test
%
%    ownPath = fileparts( which(mfilename) );
%
%    testFiles{1} = fullfile( ownPath, 'read_ref_test1.ref' );
%    testFiles{2} = fullfile( ownPath, 'read_ref_test2.ref' );
%    
%    for iFile = 1:length(testFiles)
%        
%        for gradMode = [0:2]
%            
%            interpColorOps = {[0.8,0.8,0.8],[]};
%            for iInterp = 1:length(interpColorOps)
%                
%                interpColor = interpColorOps{iInterp};
%                
%                lineColorOpts = {'k',[]};
%                for iLine = 1:length(lineColorOpts)
%                    
%                    lineColor = lineColorOpts{iLine};
%                    
%                    ref2rngOpts = {0.1,[]};
%                    for iR2r = 1:length(ref2rngOpts)
%                        
%                        ref2rng = ref2rngOpts{iR2r};
%                    
%                        [Ref,hFig,Temp] = plot_ref( ...
%                                               testFiles{iFile}, gradMode, ...
%                                               interpColor, lineColor, ...
%                                               ref2rng );
%                                           
%                        str = inputs2str(      testFiles{iFile}, gradMode, ...
%                                               interpColor, lineColor, ...
%                                               ref2rng );
%                        title( str, 'fontsize',10 );
%                        
%                        if ~exist('Handles','var')
%                            Handles = Temp;
%                        elseif ~is_equal( fieldnames(Handles), fieldnames(Temp) )
%                            error(['New "Handles" output has inconsistent',...
%                                ' fields for various calling conventions']);
%                        end
%                                           
%                    end
%                    
%                end
%                
%            end
%            
%        end
%        
%    end
%    
%    msgbox([mfilename,'''s unit tester only generates a bunch of plots, it',...
%        ' does not apply logic to automatically check for code errors.',...
%        ' Please inspect plots and also look for messsage in the Matlab window.']);
%
%return
%
function str = inputs2str( file, gradMode, interpColor, lineColor, ref2rng )

    [p,f,x] = fileparts(file);
    str = [f,x];
    
    if gradMode == 0
        str = [str,', no grads'];
    elseif gradMode == 1
        str = [str,', background grads'];
    elseif isempty(gradMode) || gradMode == 2
        str = [str,', waterfall grads'];
    else
        error('Bad gradMode flag');
    end
    
    if isempty(interpColor)
        str = [str,', empty interpColor'];        
    elseif ischar(interpColor)
        str = [str,', ''',interpColor,''' interp lines'];
    elseif isnumeric(interpColor)
        str = [str,', [',sprintf('%g,',interpColor),'] interp lines'];
    else
       error('Bad interpColor');
    end 
        
    if isempty(lineColor)
        str = [str,', empty M/N lineColor'];        
    elseif ischar(lineColor)
        str = [str,', ''',lineColor,''' M/N lineColor'];
    elseif isnumeric(lineColor)
        str = [str,', [',sprintf('%g,',lineColor),'] M/N lineColor'];
    else
       error('Bad lineColor');
    end 
    
    if isempty(ref2rng)
        str = [str,', auto ref2rng'];
    elseif isnumeric(ref2rng)
        str = [str,', ref2rng=',sprintf('%g',ref2rng)];
    else
        error('Bad ref2rng');
    end

return    
