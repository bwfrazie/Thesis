function varName = str2varname( str, makeUnique, remDupUndrs )
%str2varname - Removes invalid chars to create a usable Matlab variable name.
%
%   Note that function *is* case sensitive!  If case-insensitive results are
%   desired, one should apply UPPER or LOWER to both the input *and* the output
%   of this routine.
%
%   As of ver 7.0, Matlab introduced GENVARNAME.M, which provides nearly-
%   identical functionality to this routine.  Previous Matlab versions, however,
%   do not have access to GENVARNAME and, furthermore, this routine's variable
%   names tend to be "cleaner" when input has non-alphanumeric characters.
%   E.g., compare the following to STR2VARNAME.M "examples" below:
%       >> genvarname('abc^$%*7 .F  ') = 'abc0x5E0x240x250x2A70x2EF'
%       >> genvarname('  c^$%*7 .F  ') = 'c0x5E0x240x250x2A70x2EF'
%       >> genvarname('   ^$%*7 .F  ') = 'x0x5E0x240x250x2A70x2EF'
%       >> genvarname('   ^$%*  .   ') = 'x0x5E0x240x250x2A0x2E'
%
% USE: varName = str2varname( str );
%
% EXAMPLES:
%   str2varname('abc^$%*7 .F  ')    % output will be 'abc_7_F'
%   str2varname('  c^$%*7 .F  ')    % output will be 'c_7_F'
%   str2varname('   ^$%*7 .F  ')    % output will be 'X_7_F'
%   str2varname('   ^$%*  .   ')    % output will be 'X'
%
%
% USE: varNames = str2varname( cellStr );
%
%   Same as above, except 1) I/O are a cell of strings, not just one string, and
%   2) output strings are all unique.  Unique strings are generated by
%   successively appending numbers (1, 2, 3, etc) to non-unique names.
%
%   Note that input arrays will be *VECTORIZED* on output - i.e. this routine
%   does *NOT* work down rows or columns, but instead treats the whole input as
%   one list of strings, as follows:
%
%       Input size:    Output size:
%        [1,N]          [1,N]
%        [M,1]          [M,1]
%        [M,N]          [1,M*N] <- array has been vectorized in column order
%
% EXAMPLE:
%   str2varname({'abc^$%*7 .F  ','  c^$%*7 .F  ','   ^$%*  .   ','',''})
%   % output will be {'abc_7_F','c_7_F','X1','X2','X3'}
%
%
% USE: varNames = str2varname( ..., makeUnique, remDupUndrs )
%
%   Set the 2nd & 3rd optional inputs to false (0) to turn off code that appends
%   unique numbers and removes duplicate underscores, respectively (default
%   values for both of these inputs is true).
%
%
% Last update: 2010-08-31 (JZG)

% Update list:
% 2006-04-04 (JZG) Added makeUnique & remDupUndrs inputs/functionality.
% 2007-01-18 (Kevin Norman) Wrote tester routine.
% 2007-01-24 (JZG) Added to tester routine & fixed errors found ('X...' instead 
% of 'X_...' for inputs that don't start w/ valid character, col->row
% reorientation, and failure to operate on all elements of array cellstrings).
% 2010-08-31 (JZG) Fixed bug found by Chris Lin, whereby single-element cell or
% character input caused error (isColVectorIn var undefined).

    % Matlab's convention is to add an upper-case 'X' to front of invalid
    % variable names (e.g., in LOAD.M for text files):
    defaultName = 'X';

    if strcmpi(str,'-test') & ( nargin == 1 )
        run_test;
        return
    end
    
    if ( nargin < 2 ), remDupUndrs = 1; end
    if ( nargin < 3 ), makeUnique  = 1; end
    % NOTE: default behavior was effectively remDupUndrs=0 prior to 2006-04-04
    
    if isempty(str)
        varName = defaultName;
        return
    end
    
    isCharIn = ischar(str);
    
    if isCharIn
        str = cellstr(str);
    elseif ~iscellstr(str)
        error('1st input must be string (char array) or cellstr');
    end
    
    if is_vector( str )
        strSize = size(str);
        isColVectorIn = ( strSize(1) > strSize(2) );
    elseif length( str ) > 1
        warning('Input cellstr array has been vectorized');
        isColVectorIn = 0;
    else
        isColVectorIn = 0;        
    end
    
    if ( length(str) == 1 ), makeUnique = 0; end
    
    for i = 1:prod(size(str))
        varName{i} = str2varname1( str{i}, defaultName );
    end
    
    if ( makeUnique )
        varName = make_unique( varName );
    end
    
    if ( isCharIn )
        varName = char(varName);
    elseif ( isColVectorIn )
        varName = reshape( varName, length(varName), 1 );
    end
        
    if ( remDupUndrs ), varName = rem_adjdups( varName, '_' ); end

return





function varName = str2varname1( varName, defaultName )
%str2varname1 - Removes invalid chars to create a usable Matlab variable name.
%
% Only operates on character arrays (i.e., 1 element of a cellstr). Cellstr
% input to the main routine is handled by simply looping over calls to this
% subroutine.
%
% Last update: 2007-01-24 (JZG)

    varName = strtrim( varName );

    % Convert any non-ascii characters to underscores    
    num = double( lower(varName) ); % characters (neglecting case) -> ascii intergers
    
    % This next find relies on fact that 'a'->'z' are contiguous in ASCII set
    % and '0'->'9' are also contiguous.
    iReplace = find( ( num < double('a') | num > double('z') ) ...
                   & ( num < double('0') | num > double('9') ) );
    varName(iReplace) = '_';
    
    % Catch case where string begins with a non-valid character, as well as
    % cases where the *entire* string is non-valid characters:
    iStart = min(find( varName ~= '_' ));
    if isempty( iStart )
        varName = defaultName; % <- input empty or all non-valid characters
        return
    elseif ( iStart > 1 )
        varName = ['_',varName(iStart:end)];
    end
    
    % Also trim non-valid characters off the end of the variable name:
    iStop = max(find( varName ~= '_' ));
    varName = varName(1:iStop);
    
    % Make sure the first character is in the range 'a'->'z'
    num1 = double( lower(varName(1)) );
    if ( num1 < double('a') | num1 > double('z') )
        varName = [defaultName,varName];
    end
    
return





function varName = make_unique( varName )
% Last update: 2006-04-04

    while ( 1 )

        [uniqueNames,junk,iUnique] = unique( varName );
        
        if length(uniqueNames) == length( varName ), return; end
        
        for i = 1:length(iUnique)
            
            ii = find(iUnique==i);

            if length(ii) < 2, continue; end % cycle back to top of FOR loop
            
            for n = 1:length(ii)
                varName{ii(n)} = [varName{ii(n)},int2str(n)];
            end
            
        end            

    end

return





%function run_test
%    
%    % Test single-string input mode using the examples put forth in header
%    % comments:
%    outStr = str2varname('abc^$%*7 .F  ');
%    if ~strcmpi( outStr, 'abc_7_F'      ), error('Failed on comment ex #1'); end
%    outStr = str2varname('  c^$%*7 .F  ');
%    if ~strcmpi( outStr, 'c_7_f'        ), error('Failed on comment ex #1'); end
%    outStr = str2varname('   ^$%*7 .F  ');
%    if ~strcmpi( outStr, 'X_7_f'        ), error('Failed on comment ex #1'); end
%    outStr = str2varname('   ^$%*  .   ');
%    if ~strcmpi( outStr, 'X'            ), error('Failed on comment ex #1'); end
%
%    % Test cellstring input, again using header comment example, w/ default
%    % values for 2nd & 3rd input options (makeUnique & remDupUndrs):
%    cellIn   = {'abc^$%*7 .F  ','  c^$%*7 .F  ','   ^$%*  .   ','',''};
%    outStr   = str2varname(cellIn);
%    expected = {'abc_7_F','c_7_F','X1','X2','X3'};
%    if ~is_equal( outStr, expected, 'ignoreTranspose',0, 'ignoreCase',0 )
%        error('Failed on cellstr example (default options)');
%    end
%        
%    % Make sure that the orientation of column vectors is preserved:
%    outStr = str2varname(cellIn.');
%    if ~is_equal( outStr, expected.', 'ignoreTranspose',0, 'ignoreCase',0 )
%        error('Failed to preserve cellstr vector shape');
%    end
%    
%    % Test the various combinations of "makeUnique" & "remDupUndrs" option
%    % values:
%    expected11 = expected; % <- Default option values are both true (1).
%    expected01 = {'abc_7_F','c_7_F','X','X','X'};
%    expected10 = {'abc____7__F','c____7__F','X1','X2','X3'};
%    expected00 = {'abc____7__F','c____7__F','X','X', 'X' };
%    outStr11 = str2varname(cellIn,1,1);
%    outStr01 = str2varname(cellIn,0,1);
%    outStr10 = str2varname(cellIn,1,0);
%    outStr00 = str2varname(cellIn,0,0);
%    if ~is_equal( outStr11, expected11 ), error('Fails (1,1) option mode'); end
%    if ~is_equal( outStr01, expected01 ), error('Fails (0,1) option mode'); end
%    if ~is_equal( outStr10, expected10 ), error('Fails (1,0) option mode'); end
%    if ~is_equal( outStr00, expected00 ), error('Fails (0,0) option mode'); end
%    
%    % Finally, make sure routine is accurate for array inputs:
%    cellInA  = {'abc^$%*7 .F  ','  c^$%*7 .F  ','   ^$%*  .   ','','';...
%                'abc^$%*7 .F  ','  c^$%*7 .F  ','   ^$%*  .   ','',''};
%	expectedA = {'abc_7_F1','abc_7_F2','c_7_F1','c_7_F2','X1','X2','X3','X4','X5','X6'};
%    outStrA = str2varname(cellInA);
%    if ~is_equal( outStrA, expectedA, 'ignoreTranspose',0, 'ignoreCase',0 )
%        error('Failed for cellstr array');
%    end
%
%    disp([mfilename,' passed all internal tests']);
%
%return