function [isOk,msg] = check_ref(Ref)
%check_ref - Checks a TEMPER refractivity structure for errors.
% 
% USE: [isOk,msg] = check_ref( Ref )
%
%   Input is a structure.  If less than two outputs are specified, an error will
%   generate a modal dialog box that pauses execution before returning.
%   
%   Note that message output "msg" may not always be empty when isOk == true.
%   Issues that are not severe enough to set isOk to false will still be flagged
%   with a message, so the recommended way of calling this routine is as
%   follows:
%
% EXAMPLE:
%
%   [Ref,isOk,msg] = read_ref % note that read_ref.m calls check_ref.m
%   if ~isOk
%       error( msg ); % an error was generated by check_ref.m
%   elseif ~isempty(msg)
%       warning( msg ); % a warning was generated by check_ref.m
%   else
%       disp('This refractivity file is clean');
%   end
%   
%
% ©2003-2015, Johns Hopkins University / Applied Physics Lab
% Last update: 2015-12-01 (JZG)


% Update List: (all JZG unless noted)
% ------------
% 2003-03-18 - Finished coding initial version.
% 2003-03-28 - Fixed a few bugs & added dhArray check.
% 2004-05-06 - Check for non-zero first heights (TEMPER throws error).
% 2006-06-13 - Check for NaN's (causes TEMPER to crash)
% 2007-12-11 - Fixed bug that prevented dh <= 0 checks from catching problems in
% multi-range files, and changed dh == 0 from warning to an error based on
% recent TEMPER debugging (sometimes dh == 0 is ok, and sometimes GO crashes).
% 2008-03-31 - Check for top attenuation points.
% 2013-11-05 - Put 2008-03-31 code inside an ELSE block so improperly sized 
% arrays kick out isOk=false but do not generate an internal error in my calcs.
% Also changed the error message for attenuation extrapolation from "some
% versions of TEMPER" to "versions 3.0x and 3.1x" (3.2 fixes this).
% 2015-02-03 - Changed a few errors to warnings (i.e., set msg to a string but 
% keep isOk true) and added checks for more than 3000 & 13000 height samples.
% 2015-12-01 - Very minor clarification to the # of heights error.


    % For compatibility with R13's logical type:
    true  = (1==1);
    false = not(true);

    % Initialize output
    isOk = true;
    msg = '';

    expectedFields = {'file','comment','ref_units','units','n_profiles',...
                      'range','height','refractivity','absorption'};

	if ( nargin ~= 1 ) || ~isstruct(Ref)
        error('Invalid input - must be 1 input argument (struct)');
    end
                  
    inputFields = fieldnames(Ref);

    extraFields   = setdiff( inputFields, expectedFields );
    if ~isempty(extraFields)
        msg = [msg,'Unexpected fields [', ...
            sprintf(' ''%s'' ',extraFields{:}),'].  '];
        isOk = false;
    end

    missingFields = setdiff( expectedFields, inputFields );
    if ~isempty(missingFields)
        msg = [msg,'Missing fields [', ...
            sprintf(' ''%s'' ',missingFields{:}),'].  '];
        isOk = false;
        return % Quit, otherwise runtime errors will occur when attempting to
               % access non-existant fields of structure in code below!
    end

    switch Ref.ref_units
        case {'m','M','n','N'}
            Ref.ref_units = upper( Ref.ref_units ); % stardardize lowercase
        otherwise
            msg = [msg,'Invalid .ref_units value.  '];
            isOk = false;
    end

    switch Ref.units
        case {0,1}
            % Do nothing
        otherwise
            msg = [msg,'Invalid .units value.  '];
            isOk = false;
    end

    if not( Ref.range(1) == 0 )
        msg = [msg,'First range is not zero.  '];
        isOk = false;
    end

    nCols = size(Ref.refractivity,2);
    if not( nCols == Ref.n_profiles )
        msg = [msg,'Number of columns in .refractivity (',int2str(nCols),...
               ') does not match .n_profiles (',int2str(Ref.n_profiles),').  '];
        isOk = false;
    end

    expectedSize = [1,nCols];
    if any( size(Ref.range) ~= expectedSize )
        msg = [msg,'Size of range vector [',int2str(size(Ref.range)),...
              '] does not match expected size [',int2str(expectedSize),'].  '];
        isOk = false;
    end

    if any( size(Ref.refractivity) ~= size(Ref.height) )
        msg = [msg,'Size of height array [',int2str(size(Ref.height)),...
                '] does not match size of refractivity array [',...
                int2str(size(Ref.refractivity)),'.  '];
        isOk = false;
    end

    dhArray = diff( Ref.height, 1, 1 ); % (i,j) = (i,j) - (i,j+1)
    if any( [dhArray(:)] < 0.0 ) % <- [ (:)] corrects bug for multi-range files 2007-12-11
        msg = [msg,'Heights are not all monotonically increasing (processing errors',...
                ' or transposed array?)  '];
        isOk = false;
    elseif any( [dhArray(:)] == 0.0 ) % <- [ (:)] corrects bug, 2007-12-11
        thisMsg = 'Transposed height array? Or - more likely - duplicated heights in array.  '
        thisMsg = [thisMsg,'In some cases (not all!) this will cause TEMPER to crash.  ']; % <- added 2007-12-11
        msg = [msg, thisMsg, '  '];
        %PRE: warning( thisMsg ); % <- commented out 2007-12-11
        %isOk = false; % <- added 2007-12-11, commented out 2015-02-03
        % ... this will be treated as an "ok" warning from now on
    end
    
    firstHeights = Ref.height(1,:);
    if any( firstHeights > 0.0 )
        msg = [msg,'height(s) > 0.0 detected at start of 1 or more profiles.  '];
        isOk = false;
    end
    
    % NaN entries cause the follow run-time crash in TEMPER:
    %   forrtl: severe (59): list-directed I/O syntax error, unit 10, file ...
    isAnyNan = any( isnan( [Ref.height(:)]       ) ) | ...
               any( isnan( [Ref.refractivity(:)] ) ) | ...
               any( isnan( [Ref.absorption(:)]   ) ) | ...
               any( isnan(  Ref.range            ) );
    if any( isAnyNan )
        msg = [msg,'1 or more NaN entries detected - TEMPER will crash!  '];
        isOk = false;
    end        
    
    if not( isempty( Ref.absorption ) )
        if any( Ref.absorption < 0 )
            % Added 2008-03-31, but logic wasn't proper until 2013-11-05
            msg = [msg,'Some attenuation values are negative.  '];
            isOk = false;
        end
        if any( size(Ref.absorption) ~= size(Ref.height) )
            msg = [msg,'Size of absorption array [',int2str(size(Ref.absorption)),...
                    '] does not match size of refractivity array [',...
                    int2str(size(Ref.refractivity)),'].  '];
            isOk = false;
        else
            % Figure out what the topmost gradient is in absorption array; TEMPER
            % will extrapolate this upward *even* if the extrapolation causes
            % unphysically large attenuation or *negative* attenuation (gain):
            dAtten      = diff( Ref.absorption, 1, 1 );
            dAttenDhTop = dAtten(end,:) ./ dhArray(end,:);
            % Check what would happen if TEMPER extrapolated the current attenuation
            % values up to "hCheck" in altitude. If the current file already
            % specifies attenuation values up to this height, at least check to see
            % what would happen if the values were extrapolated upward a small
            % amount (deltaMin) to make sure nothing crazy is going on up there...
            [rngUnits,hgtUnits] = unitflag2str( Ref.units );
            hCheck          = convert_length(  20, 'km', hgtUnits );
            deltaMin        = convert_length( 100,  'm', hgtUnits );
            deltaToCheckHgt = hCheck - Ref.height(end,:);
            deltaToCheckHgt = max( deltaToCheckHgt, deltaMin );
            % Make sure the extrapolated value does not A) become appreciably
            % negative, or B) greatly exceeds the topmost attenuation value already
            % in the file:
            extrapValue     = dAttenDhTop .* deltaToCheckHgt;
            topAttenInFile  = Ref.absorption(end,:);
            significantRngTo1Db = convert_length( 100, 'nmi', hgtUnits ); % 1/km -> 1/hgtUnits
            errTol = 1/(2*significantRngTo1Db); % 2* for two-way
            if any( extrapValue < -errTol ) | any( extrapValue > topAttenInFile+errTol )
                noProblemBelowHgt = min( Ref.height(end,:) );
                msg = [msg,'Attenuation values end with a gradient that',...
                      ' could be improperly interpolated by versions 3.0x and',...
                      ' 3.1x of TEMPER; please extend the height of your .ref',...
                      ' file if using those versions for TEMPER calculations above ',...
                      int2str(noProblemBelowHgt),' ',hgtUnits,' in altitude).  '];
                %isOk = false; <- commented out 2015-02-03
                % ... now treated as a warning
            end        
            % End of 2008-03-31 additions
        end
    end
    
    % New, 2015-02-03
    nHgts = length( Ref.height );
    if ( nHgts > 3000 )
        msg = [msg,'This profile contains ',int2str(nHgts),' altitudes.',...
                ' TEMPER v3.0.0-3.1.2 will crash if run with GO grazing',...
                ' or using automatic angles in certain cases. '];
        if ( nHgts > 13000 )
            msg = [msg,'TEMPER v3.2.0 will have the same problems unless',...
                ' this profile is thinned to <= 13,000 altitudes.  '];
        else
            msg = [msg,'TEMPER v3.2.0, however, will not have problems',...
                ' for this profile.'];
        end
        % Do not set isOk = false, treat it as a warning since it can be worked
        % around by turning of GO mode.
    end

    % Create modal error-dialog box (suspend execution) if an error
    % occurred and caller did not specify the second output argument:
    isWarning = ~isempty(msg) & isOk;
    isError   = ~isOk;
    if ( nargout < 2 ) & ( isError | isWarning )
        if isError
            h = errordlg(msg,mfilename,'modal');
        else
            h = warndlg(msg,mfilename,'modal');
        end
        waitfor(h);
    end
    
return